# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lQBYJEPNWS7AiLiMnbBSOC-meEj3-ejc
"""

class MiClase():
  def __init__(self):
    self.y=2

  def operar(self, x):
    return x * self.y

n = MiClase()
n.operar(2)

import torch
import torch.nn as nn
import torch.optim as optim
#import pdb

wh = torch.Tensor( [2.0,-3.0,-3.0]) # , requires_grad=True)
#wh.requires_grad_(True)
x = torch.Tensor( [-1.0, -2.0] )
xx = torch.Tensor( [-1.0, -2.0, 1.0] )
t = torch.Tensor( [0.5] )
M = torch.Tensor()

class Perceptron( nn.Module ):
  def __init__( self):   #, weights ):
    super( Perceptron, self ).__init__()
    self.layer = nn.Linear( 2, 1 )
#    with torch.no_grad():
#      self.layer.weight.copy_( weights[:2] )
#      self.layer.bias.copy_( weights[2] )
    self.sigmoid = nn.Sigmoid()
  def forward( self, x ):
    x = self.sigmoid( self.layer(x) )
    return x

def my_hook(grad):
  print('>>',grad)
  return grad

#wh.register_hook(my_hook)
#wh.register_hook(lambda grad:print(grad))
#wh.retain_grad()

#register_full_backward_hook 
def my_hook_bg(module, input, output):
  print(input, output)
  return input

model = Perceptron( ) #wh
#model.register_backward_hook(my_hook_bg)
##model.register_full_backward_hook(my_hook_bg)

mse_loss = nn.MSELoss()
optimizer = optim.SGD( model.parameters(), lr = 0.01 ) # Learning rate equal to 0.01

pr = model( x )          # forward step
loss_value = mse_loss( pr, t )
print( 'First output value: %.4f' % (pr) )
while loss_value.item() > 1e-4:
  #pdb.set_trace()
  print('X y W =>>> ', x, wh)
  M = torch.matmul(xx,wh)
  print('X x W =>> ', M)
  loss_value.backward() # backward step
  #pdb.set_trace()
  optimizer.step()      # weights update
  pr = model( x )        # forward step
  loss_value = mse_loss( pr, t )
  print( 'current loss: %.4f  pr:%.4f - target:%.4f' % (loss_value.item() , pr, t))
  print('\n')
print( 'Last output value: %.4f' % (pr) )

torch.save(model.state_dict(), "model.pt")

def main():
  pass
#  torch.onnx.export()

if __name__ == '__main__':
  main()